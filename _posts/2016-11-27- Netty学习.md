---
layout:     post
title:      Netty
subtitle:   Netty 简单学习
date:       2018-11-27
author:     uugit
header-img: img/post-bg-rwd.jpg
catalog: true
tags:
    - Netty
---

基于Netty4.1版本, 简单介绍理论模型, 使用场景, 基本组件, 整体架构

#### Netty简介
>  Netty 是一个异步事件驱动的网络应用程序框架, 用于快速开发可维护的高性能协议服务器和客户端


#### JDK 原生NIO程序问题
JDK 原生也有一套网络应用程序API, 但是存在一些问题,
* NIO的类库和API 比较复杂, 使用麻烦, 需要熟练掌握Selector, ServerSocketChannel, SocketChannel, ByteBuffer等
* 需要有额外的技能, 比如: JAVA多线程, 因为NIO 编程涉及到Reactor模式, 必须对多线程和网络编程熟悉, 才能写出高质量NIO程序
* 可靠性能力补齐, 开发工作量和难度都非常大, 例如: `客户端面临断线重连, 网络闪断, 半包读写, 失败缓存, 网络拥塞, 异常码流的处理`等等, NIO编程的特点是功能开发相对容易, 但是可靠性能力补齐工作量和难度都非常大
* JDK NIO的BUG, 比如`epoll bug, 会导致Selector空轮询`, 最终导致CPU 跑满, 官方说已经解决, 好像是没有根本解决

#### Netty 的特点
* 设计优雅
   * 适用于各种传输类型的统一API- `阻塞和非阻塞Socket`
   * 基于灵活且可扩展的事件模型
   * 高度可定制线程模型 - `单线程, 一个或多个线程池`
   * 真正的无连接数据报套接字支持(自3.1起)

* 使用方便
  * 详细记录的Javadoc, 用户指南和示例
  * 没有其他依赖, JDK5(Netty 3.x)或6 (Netty 4.x) 就足够了


* 高性能
  * 吞吐量更高, 延迟更低
  * 减少资源消耗
  * 最小化不必要的内存复制

* 安全
  * 完整的SSL /TLS 和StartTLS 支持

* 社区活跃, 不断更新
  * 版本一直在迭代, 发现BUG 可以及时修复, 后续新功能会被加入

![Image](/img/netty_0.png)


#### Netty 常见使用场景
* 互联网行业
  * 典型的应用有：阿里分布式服务框架Dubbo的RPC框架使用Dubbo协议进行节点间通信，Dubbo协议默认使用Netty作为基础通信组件，用于实现各进程节点之间的内部通信。
* 游戏行业
  * 手游服务端 , 大型的网络游戏, Netty作为高性能的基础通信组件, 它本身提供了TCP/UDP和HTTP协议栈
  * 非常方便定制和开发私有协议栈, 账号登录服务器, 地图服务器之间可以方便的通过Netty进行高性能通信
* 大数据领域
  * 经典的Hadoop的高性能通信和`序列化组件Avro的RPC框架`, 默认采用Netty进行跨界点通信，它的Netty Service基于Netty框架二次封装实现



#### Netty 高性能设计
 Netty作为异步事件驱动的网络, 高性能之处主要来自`I/O 模型和线程处理模型`, 前者决定如何收发数据, 后者决定如何处理数据

##### I/O模型
 用什么样的通道将数据发送给对方, BIO, NIO或者AIO, I/O模型在很大程度上决定了框架的性能

##### 阻塞I/O模型
 传统阻塞型I/O(BIO), 如下图:

![Image](/img/netty_1.png)
 * 特点:
   * 每个请求都需要独立的线程完成数据的read, 业务处理, 数据write的完整操作

 * 问题:
   * 当并发数较大时, 需要创建大量的线程来处理连接, 系统资源占用比较大
   * 连接建立后, 如果当前线程并没有数据可以读, 则线程就阻塞在read操作上, 造成线程资源浪费

##### I/O复用模型
 I/O复用模型 , 如下图:

![Image](/img/netty_2.png)
 在I/O复用模型中, 会用到select, 这个函数会使进程阻塞, 但是和阻塞I/O所不同的,
 * 特点:
   * 可以同时阻塞多个I/O操作
   * 可以同时对多个读操作, 多个写操作的I/O函数检测, 直到有数据可读或可写时, 才真正调用I/O操作函数

Netty的非阻塞I/O的实现关键是基于I/O复用模型，这里用Selector对象表示：
![Image](/img/netty_3.png)

Netty的I/O线程 NioEventLoop由于聚合了`多路复用器Selector`, 可以同时并发处理成百上千个客户端连接, 当线程从某客户端Socket通道进行读写数据时,
若没有数据可用时, 该线程可以进行其他任务, 线程通常将非阻塞IO的空闲时间用于在其他通道上执行IO操作, 所以单独的线程可以管理多个输入和输出管道


> 由于读写操作都是非阻塞的, 这就可以充分提升 IO线程的运行效率, 避免由于频繁I/O阻塞导致线程挂起, 一个I/O线程可以并发处理N个客户端连接和读写操作, 这从根本上解决了
传统同步阻塞I/O -连接-线程模型, 架构的性能, 弹性伸缩能力和可靠性都得到了极大的提升

##### Buffer

* 传统的I/O 是面向字节流或者字符流的, 以流式的方式顺序的从一个Stream中读取一个或多个字节, 因此也就不能随意改变读取指针的位置
* 在NIO中, 有了Channel和Buffer, `只能从Channel中读取数据到Buffer` 或者 `将数据从Buffer中写入到Channel`
* 基于Buffer操作, `在NIO中可以随意的读取任意位置的数据`


